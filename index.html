<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>B·∫£ng X·∫øp H·∫°ng Realtime - T√¢n Binh To√†n NƒÉng 2025</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèÜ</text></svg>">
  <style>
    :root {
      --color-primary: #667eea;
      --color-secondary: #764ba2;
      --color-success: #51cf66;
      --color-warning: #ffa726;
      --color-error: #ff6b6b;
      --color-text: #333;
      --color-white: #ffffff;
      --color-bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--color-bg-gradient);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container { max-width: 1200px; margin: 0 auto; }
    
    .header { text-align: center; color: var(--color-white); margin-bottom: 30px; }
    .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    
    .status-bar { 
      display: flex; 
      justify-content: center; 
      gap: 20px; 
      flex-wrap: wrap; 
      margin-top: 15px; 
    }
    
    .status-item { 
      background: rgba(255,255,255,0.2); 
      padding: 8px 15px; 
      border-radius: 20px; 
      font-size: 0.85em; 
      color: var(--color-white); 
    }
    
    .status-online { color: #90EE90; font-weight: bold; }
    .status-error { color: var(--color-error); font-weight: bold; }
    
    .action-buttons { 
      display: flex; 
      justify-content: center; 
      gap: 15px; 
      flex-wrap: wrap; 
      margin-bottom: 20px; 
    }
    
    .btn {
      background: rgba(255,255,255,0.2); 
      color: var(--color-white); 
      border: 2px solid var(--color-white);
      padding: 12px 30px; 
      border-radius: 10px; 
      cursor: pointer; 
      font-size: 1em;
      transition: all 0.3s ease; 
      font-weight: bold; 
      display: flex; 
      align-items: center; 
      gap: 8px;
    }
    
    .btn:hover { background: rgba(255,255,255,0.3); transform: scale(1.05); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .btn-success { background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%); }
    .btn-warning { background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); }
    
    .leaderboard { 
      background: var(--color-white); 
      border-radius: 20px; 
      padding: 30px; 
      box-shadow: 0 10px 40px rgba(0,0,0,0.2); 
    }
    
    .contestant {
      display: flex; 
      align-items: center; 
      padding: 20px; 
      margin-bottom: 15px;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      border-radius: 15px; 
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .contestant:hover { transform: translateY(-3px); box-shadow: 0 5px 20px rgba(0,0,0,0.15); }
    .contestant.rank-1 { background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); }
    .contestant.rank-2 { background: linear-gradient(135deg, #C0C0C0 0%, #808080 100%); }
    .contestant.rank-3 { background: linear-gradient(135deg, #CD7F32 0%, #8B4513 100%); }
    
    .rank { font-size: 2em; font-weight: bold; width: 60px; text-align: center; color: var(--color-text); }
    .rank-1 .rank, .rank-2 .rank, .rank-3 .rank { color: var(--color-white); text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    
    .avatar { 
      width: 80px; 
      height: 80px; 
      border-radius: 50%; 
      object-fit: cover; 
      border: 4px solid var(--color-white); 
      margin-right: 20px; 
      box-shadow: 0 4px 8px rgba(0,0,0,0.2); 
    }
    
    .info { flex: 1; }
    .name { font-size: 1.4em; font-weight: bold; color: var(--color-text); margin-bottom: 5px; }
    .rank-1 .name, .rank-2 .name, .rank-3 .name { color: var(--color-white); }
    
    .stats { display: flex; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
    
    .stat-item {
      display: flex; 
      align-items: center; 
      gap: 5px; 
      font-size: 0.85em;
      background: rgba(255,255,255,0.4); 
      padding: 4px 10px; 
      border-radius: 12px;
    }
    
    .rank-1 .stat-item, .rank-2 .stat-item, .rank-3 .stat-item { color: var(--color-white); font-weight: 600; }
    
    .increase { color: #27ae60; font-weight: bold; }
    .rank-1 .increase, .rank-2 .increase, .rank-3 .increase { color: #90EE90; }
    
    .speed { color: #3498db; font-weight: bold; }
    .rank-1 .speed, .rank-2 .speed, .rank-3 .speed { color: #ADD8E6; }
    
    .gap { color: #e74c3c; font-weight: bold; }
    .rank-1 .gap, .rank-2 .gap, .rank-3 .gap { color: #ffcccc; }
    
    .points-container { text-align: right; min-width: 150px; }
    .points { font-size: 1.8em; font-weight: bold; color: var(--color-primary); }
    .rank-1 .points, .rank-2 .points, .rank-3 .points { color: var(--color-white); }
    .points-label { font-size: 0.55em; display: block; opacity: 0.8; }
    
    .loading { text-align: center; padding: 40px; color: #666; font-size: 1.2em; }
    
    .message { 
      padding: 15px; 
      border-radius: 10px; 
      text-align: center; 
      margin-bottom: 20px; 
      color: var(--color-white); 
      animation: slideIn 0.3s ease; 
    }
    
    .message.error { background: var(--color-error); }
    .message.success { background: var(--color-success); }
    .message.warning { background: var(--color-warning); }
    
    @keyframes slideIn { 
      from { transform: translateY(-20px); opacity: 0; } 
      to { transform: translateY(0); opacity: 1; } 
    }
    
    .refresh-info { 
      text-align: center; 
      color: var(--color-white); 
      margin-top: 20px; 
      font-size: 0.9em; 
      opacity: 0.9; 
    }
    
    .csv-info { 
      background: rgba(255,255,255,0.15); 
      color: var(--color-white); 
      padding: 15px; 
      border-radius: 10px; 
      margin-top: 20px; 
      text-align: center; 
      font-size: 0.9em; 
    }
    
    .csv-info strong { color: #90EE90; }
    
    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }
    .updating { animation: pulse 1.5s ease-in-out infinite; }
    
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }
    .live-dot { 
      display: inline-block; 
      width: 10px; 
      height: 10px; 
      border-radius: 50%; 
      margin-right: 5px; 
      animation: blink 2s ease-in-out infinite; 
    }
    
    .live-dot.green { background: #90EE90; }
    .live-dot.red { background: var(--color-error); animation-duration: 1s; }
    
    @media (max-width: 768px) {
      .header h1 { font-size: 1.8em; }
      .contestant { padding: 12px; flex-wrap: wrap; }
      .rank { font-size: 1.5em; width: 40px; }
      .avatar { width: 60px; height: 60px; margin-right: 12px; }
      .name { font-size: 1.1em; }
      .points { font-size: 1.3em; }
      .stats { width: 100%; }
      .points-container { min-width: auto; }
      .action-buttons { flex-direction: column; }
      .btn { width: 100%; justify-content: center; }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>üèÜ B·∫£ng X·∫øp H·∫°ng T√¢n Binh To√†n NƒÉng 2025</h1>
    <div class="status-bar">
      <div class="status-item" id="connectionStatus">
        <span class="live-dot green"></span>
        <span class="status-online">REALTIME</span>
      </div>
      <div class="status-item" id="lastUpdate">ƒêang t·∫£i...</div>
      <div class="status-item" id="countdown">--:--</div>
      <div class="status-item" id="viewerCount">üë• ---</div>
    </div>
  </div>

  <div class="action-buttons">
    <button class="btn" id="refreshBtn" onclick="manualRefresh()">üîÑ C·∫≠p nh·∫≠t ngay</button>
    <button class="btn btn-success" onclick="downloadCSV()">üì• T·∫£i CSV hi·ªán t·∫°i</button>
    <button class="btn btn-success" onclick="downloadAllHistory()">üìä T·∫£i l·ªãch s·ª≠ CSV</button>
    <button class="btn btn-warning" onclick="clearAllData()">üóëÔ∏è X√≥a d·ªØ li·ªáu</button>
  </div>

  <div id="messageContainer"></div>
  <div id="leaderboard" class="leaderboard">
    <div class="loading">‚è≥ ƒêang t·∫£i d·ªØ li·ªáu...</div>
  </div>

  <div class="refresh-info">
    ‚ö° T·ª± ƒë·ªông c·∫≠p nh·∫≠t m·ªói <strong>1 PH√öT</strong> | üìä Hi·ªÉn th·ªã Gap + T·ªëc ƒë·ªô tƒÉng ƒëi·ªÉm Top 5 | üíæ T·ª± ƒë·ªông l∆∞u CSV<br>
    ‚úÖ <strong>S·∫µn s√†ng deploy l√™n GitHub Pages</strong> - Ch·∫°y 100% tr√™n tr√¨nh duy·ªát
  </div>
  <div class="csv-info">
    üìÅ CSV t·ª± ƒë·ªông l∆∞u: <strong id="csvCount">0</strong> l·∫ßn |
    üïê L·∫ßn cu·ªëi: <strong id="lastCsvTime">Ch∆∞a c√≥</strong>
  </div>
</div>

<script>
  const API_URL = 'https://eventista-platform-api.1vote.vn/v1/internal/tenants/lsvBBR/products?eventId=EVENT_IZDYX';
  const UPDATE_INTERVAL = 60 * 1000;
  const STORAGE_KEY = 'tbtn_data';
  const STORAGE_TIME_KEY = 'tbtn_time';
  const CSV_HISTORY_KEY = 'tbtn_csv_history';
  const CSV_COUNT_KEY = 'tbtn_csv_count';

  let previousData = null;
  let lastUpdateTime = null;
  let lastSuccessfulUpdate = null;
  let countdownInterval = null;
  let isUpdating = false;
  let csvHistory = [];
  let csvCount = 0;
  let updateTimer = null;

  function init() {
    console.log('üöÄ App Initialized');
    console.log('üì° API URL:', API_URL);
    
    loadFromMemory();
    loadCSVHistory();
    updateViewerCount();
    setInterval(updateViewerCount, 30000);
    updateTimer = setInterval(updateLeaderboard, UPDATE_INTERVAL);
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && lastUpdateTime && Date.now() - lastUpdateTime > UPDATE_INTERVAL) {
        updateLeaderboard();
      }
    });
    
    console.log('‚è≥ Fetching initial data...');
    updateLeaderboard();
  }

  function saveToMemory(data) {
    previousData = data;
    lastUpdateTime = Date.now();
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      localStorage.setItem(STORAGE_TIME_KEY, Date.now().toString());
      console.log('üíæ Saved to localStorage');
    } catch (e) {
      console.error('‚ùå Cannot save to localStorage:', e);
    }
  }

  function loadFromMemory() {
    try {
      const savedData = localStorage.getItem(STORAGE_KEY);
      const savedTime = localStorage.getItem(STORAGE_TIME_KEY);
      
      if (savedData && savedTime) {
        previousData = JSON.parse(savedData);
        lastUpdateTime = parseInt(savedTime);
        lastSuccessfulUpdate = lastUpdateTime;
        renderLeaderboard(previousData);
        startCountdown();
        console.log('‚úÖ Loaded from localStorage');
      }
    } catch (e) {
      console.error('‚ùå Cannot load from localStorage:', e);
    }
  }

  function loadCSVHistory() {
    try {
      const saved = localStorage.getItem(CSV_HISTORY_KEY);
      const count = localStorage.getItem(CSV_COUNT_KEY);
      
      if (saved) csvHistory = JSON.parse(saved);
      if (count) {
        csvCount = parseInt(count);
        updateCSVInfo();
      }
    } catch (e) {
      console.error('‚ùå Cannot load CSV history:', e);
    }
  }

  function saveCSVHistory() {
    try {
      if (csvHistory.length > 100) csvHistory = csvHistory.slice(-100);
      localStorage.setItem(CSV_HISTORY_KEY, JSON.stringify(csvHistory));
      localStorage.setItem(CSV_COUNT_KEY, csvCount.toString());
      updateCSVInfo();
    } catch (e) {
      console.error('‚ùå Cannot save CSV history:', e);
    }
  }

  function clearAllData() {
    if (!confirm('‚ö†Ô∏è X√≥a T·∫§T C·∫¢ d·ªØ li·ªáu v√† l·ªãch s·ª≠ CSV?')) return;
    
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(STORAGE_TIME_KEY);
    localStorage.removeItem(CSV_HISTORY_KEY);
    localStorage.removeItem(CSV_COUNT_KEY);
    
    previousData = null;
    lastUpdateTime = null;
    csvHistory = [];
    csvCount = 0;
    
    updateCSVInfo();
    showMessage('‚úÖ ƒê√£ x√≥a t·∫•t c·∫£ d·ªØ li·ªáu!', 'success');
    updateLeaderboard();
  }

  function updateCSVInfo() {
    document.getElementById('csvCount').textContent = csvCount;
    if (csvHistory.length > 0) {
      document.getElementById('lastCsvTime').textContent =
        new Date(csvHistory[csvHistory.length - 1].timestamp).toLocaleString('vi-VN');
    }
  }

  // CORS Proxies v·ªõi th·ª© t·ª± ∆∞u ti√™n
  const CORS_PROXIES = [
    'https://api.allorigins.win/raw?url=',
    'https://corsproxy.io/?',
    'https://api.codetabs.com/v1/proxy?quest=',
  ];
  let currentProxyIndex = 0;
  const MAX_RETRIES = 5;
  const RETRY_INTERVAL = 10000;
  let retryCount = 0;

  async function fetchData() {
    for (let proxyAttempt = 0; proxyAttempt < CORS_PROXIES.length; proxyAttempt++) {
      try {
        const proxy = CORS_PROXIES[currentProxyIndex];
        const url = proxy + encodeURIComponent(API_URL);
        
        console.log(`üîÑ [Proxy ${currentProxyIndex + 1}/${CORS_PROXIES.length}] Fetching:`, proxy);
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);
        
        const res = await fetch(url, {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
          cache: 'no-cache',
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        const json = await res.json();
        console.log('‚úÖ API Response:', json);

        if (json.errorCode === 0 && json.data?.products) {
          console.log(`üì¶ Loaded ${json.data.products.length} products`);
          updateConnectionStatus(true);
          retryCount = 0;
          return json.data.products;
        }
        
        throw new Error(json.message || 'D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá');

      } catch (err) {
        console.error(`‚ùå Proxy ${currentProxyIndex + 1} failed:`, err.message);
        currentProxyIndex = (currentProxyIndex + 1) % CORS_PROXIES.length;
        
        if (proxyAttempt === CORS_PROXIES.length - 1) {
          updateConnectionStatus(false);
          return null;
        }
        
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    return null;
  }

  async function retryFetch() {
    if (retryCount >= MAX_RETRIES) {
      console.log('‚ùå Max retries reached');
      showMessage('‚ö†Ô∏è Kh√¥ng th·ªÉ k·∫øt n·ªëi sau nhi·ªÅu l·∫ßn th·ª≠. Hi·ªÉn th·ªã d·ªØ li·ªáu c≈©.', 'warning');
      retryCount = 0;
      return null;
    }
    
    retryCount++;
    console.log(`üîÑ Retry ${retryCount}/${MAX_RETRIES}...`);
    
    const products = await fetchData();
    if (products) return products;
    
    await new Promise(resolve => setTimeout(resolve, RETRY_INTERVAL));
    return await retryFetch();
  }

  function formatNumber(n) {
    return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, '.');
  }

  function formatTime() {
    return new Date().toLocaleString('vi-VN', {
      hour: '2-digit', minute: '2-digit', second: '2-digit',
      day: '2-digit', month: '2-digit', year: 'numeric'
    });
  }

  function calculateStats(current, previous) {
    if (!previous || !lastSuccessfulUpdate) return current;
    const timeDiff = (Date.now() - lastSuccessfulUpdate) / 60000;
    return current.map(c => {
      const prev = previous.find(p => p.id === c.id);
      if (!prev) return c;
      const pointsIncrease = c.points - prev.points;
      const speed = timeDiff > 0 ? Math.round(pointsIncrease / timeDiff) : 0;
      return { ...c, pointsIncrease, speed };
    });
  }

  function renderLeaderboard(products) {
    const sorted = [...products].sort((a, b) => b.points - a.points);
    const withStats = calculateStats(sorted, previousData ? [...previousData].sort((a, b) => b.points - a.points) : null);

    const html = withStats.map((c, index) => {
      const rank = index + 1;
      const rankClass = rank <= 3 ? `rank-${rank}` : '';
      const isTop5 = rank <= 5;
      let statsHtml = '';

      if (isTop5) {
        const items = [];
        if (rank > 1) {
          const gap = withStats[index - 1].points - c.points;
          items.push(`<div class="stat-item">üìâ <span class="gap">-${formatNumber(gap)} ƒëi·ªÉm</span></div>`);
        }
        if (c.pointsIncrease !== undefined) {
          items.push(`<div class="stat-item">üìà <span class="increase">+${formatNumber(c.pointsIncrease)}</span></div>`);
          items.push(`<div class="stat-item">‚ö° <span class="speed">${formatNumber(c.speed)} ƒë/ph√∫t</span></div>`);
        }
        if (items.length) statsHtml = `<div class="stats">${items.join('')}</div>`;
      }

      return `
        <div class="contestant ${rankClass}">
          <div class="rank">#${rank}</div>
          <img src="${c.avatar}" alt="${c.name}" class="avatar" onerror="this.src='https://placehold.co/80x80'">
          <div class="info">
            <div class="name">${c.name}</div>
            ${statsHtml}
          </div>
          <div class="points-container">
            <div class="points">${formatNumber(c.points)}<span class="points-label">ƒëi·ªÉm</span></div>
          </div>
        </div>`;
    }).join('');

    document.getElementById('leaderboard').innerHTML = html;
    document.getElementById('lastUpdate').textContent = `üïê ${formatTime()}`;
  }

  async function updateLeaderboard() {
    if (isUpdating) {
      console.log('‚ö†Ô∏è Already updating, skip');
      return;
    }
    
    isUpdating = true;
    const lb = document.getElementById('leaderboard');
    const btn = document.getElementById('refreshBtn');
    lb.classList.add('updating');
    btn.disabled = true;
    btn.textContent = '‚è≥ ƒêang c·∫≠p nh·∫≠t...';

    console.log('üîÑ Starting update...');
    let products = await fetchData();
    
    if (!products) {
      console.log('‚ö†Ô∏è Fetch failed, trying retry...');
      products = await retryFetch();
    }

    if (products) {
      console.log('‚úÖ Update successful!');
      renderLeaderboard(products);
      saveToMemory(products);
      autoSaveCSV(products);
      previousData = products;
      lastUpdateTime = Date.now();
      lastSuccessfulUpdate = Date.now();
      startCountdown();
      document.getElementById('messageContainer').innerHTML = '';
    } else if (previousData) {
      console.log('‚ö†Ô∏è Showing old data');
      renderLeaderboard(previousData);
      showMessage('‚ö†Ô∏è Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t, ƒëang hi·ªÉn th·ªã d·ªØ li·ªáu c≈©', 'warning');
    } else {
      console.log('‚ùå No data available');
      lb.innerHTML = '<div class="loading">‚ùå Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Th·ª≠ l·∫°i sau.</div>';
      showMessage('‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi API!', 'error');
    }

    lb.classList.remove('updating');
    btn.disabled = false;
    btn.innerHTML = 'üîÑ C·∫≠p nh·∫≠t ngay';
    isUpdating = false;
  }

  function manualRefresh() {
    console.log('üîÑ Manual refresh...');
    retryCount = 0;
    updateLeaderboard();
  }

  function startCountdown() {
    if (countdownInterval) clearInterval(countdownInterval);
    countdownInterval = setInterval(() => {
      if (!lastUpdateTime) return;
      const remaining = lastUpdateTime + UPDATE_INTERVAL - Date.now();
      if (remaining <= 0) {
        document.getElementById('countdown').textContent = '‚è≥ ƒêang c·∫≠p nh·∫≠t...';
        return;
      }
      const m = Math.floor(remaining / 60000);
      const s = Math.floor((remaining % 60000) / 1000);
      document.getElementById('countdown').textContent =
        `‚è±Ô∏è ${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }, 1000);
  }

  function showMessage(msg, type = 'success') {
    const el = document.getElementById('messageContainer');
    el.innerHTML = `<div class="message ${type}">${msg}</div>`;
    setTimeout(() => { el.innerHTML = ''; }, 5000);
  }

  function updateConnectionStatus(online) {
    document.getElementById('connectionStatus').innerHTML = online
      ? '<span class="live-dot green"></span><span class="status-online">REALTIME</span>'
      : '<span class="live-dot red"></span><span class="status-error">L·ªñI K·∫æT N·ªêI</span>';
  }

  function updateViewerCount() {
    document.getElementById('viewerCount').textContent =
      `üë• ${Math.floor(Math.random() * 50) + 100} ƒëang xem`;
  }

  function autoSaveCSV(products) {
    try {
      const sorted = [...products].sort((a, b) => b.points - a.points);
      const top1 = sorted[0].points;
      csvHistory.push({
        timestamp: Date.now(),
        data: sorted.map((p, i) => ({
          rank: i + 1, id: p.id, name: p.name, points: p.points,
          gap: i > 0 ? sorted[i-1].points - p.points : null,
          percent: i > 0 ? ((top1 - p.points) / top1 * 100) : 0,
          avatar: p.avatar
        }))
      });
      csvCount++;
      saveCSVHistory();
    } catch(e) {
      console.error('CSV save error:', e);
    }
  }

  function convertToCSV(products) {
    const sorted = [...products].sort((a, b) => b.points - a.points);
    const top1 = sorted[0].points;
    const ts = new Date().toLocaleString('vi-VN');
    let csv = '\uFEFF' + 'H·∫°ng,ID,T√™n,ƒêi·ªÉm,Gap v·ªõi h·∫°ng tr∆∞·ªõc,% so v·ªõi #1,Avatar URL,Th·ªùi gian\n';
    sorted.forEach((c, i) => {
      const gap = i === 0 ? '---' : `-${sorted[i-1].points - c.points}`;
      const pct = i === 0 ? '100%' : `-${((top1 - c.points) / top1 * 100).toFixed(2)}%`;
      csv += `${i+1},"${c.id}","${c.name}",${c.points},"${gap}","${pct}","${c.avatar}","${ts}"\n`;
    });
    return csv;
  }

  function downloadCSV() {
    if (!previousData?.length) return showMessage('Ch∆∞a c√≥ d·ªØ li·ªáu!', 'error');
    triggerDownload(convertToCSV(previousData), `leaderboard_${Date.now()}.csv`);
    showMessage('‚úÖ ƒê√£ t·∫£i CSV!', 'success');
  }

  function downloadAllHistory() {
    if (!csvHistory.length) return showMessage('Ch∆∞a c√≥ l·ªãch s·ª≠!', 'error');
    let csv = '\uFEFF' + 'Th·ªùi gian,H·∫°ng,ID,T√™n,ƒêi·ªÉm,Gap,% so v·ªõi #1,Avatar\n';
    csvHistory.forEach(r => {
      const t = new Date(r.timestamp).toLocaleString('vi-VN');
      r.data.forEach(c => {
        const gap = c.gap !== null ? `-${c.gap}` : '---';
        const pct = c.rank === 1 ? '100%' : `-${c.percent.toFixed(2)}%`;
        csv += `"${t}",${c.rank},"${c.id}","${c.name}",${c.points},"${gap}","${pct}","${c.avatar}"\n`;
      });
    });
    triggerDownload(csv, `leaderboard_history_${Date.now()}.csv`);
    showMessage(`‚úÖ ƒê√£ t·∫£i l·ªãch s·ª≠ ${csvHistory.length} l·∫ßn!`, 'success');
  }

  function triggerDownload(content, filename) {
    const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  init();
</script>
</body>
</html>
